<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>main API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#main.app">app</a></li>
    <li class="mono"><a href="#main.ask">ask</a></li>
    <li class="mono"><a href="#main.logger">logger</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#main.account_is_linked">account_is_linked</a></li>
    <li class="mono"><a href="#main.convert_to_datetime_from_milliseconds">convert_to_datetime_from_milliseconds</a></li>
    <li class="mono"><a href="#main.convert_to_seconds_from">convert_to_seconds_from</a></li>
    <li class="mono"><a href="#main.get_index_where_next_char_occurs">get_index_where_next_char_occurs</a></li>
    <li class="mono"><a href="#main.get_last_of_month">get_last_of_month</a></li>
    <li class="mono"><a href="#main.get_time_of_day">get_time_of_day</a></li>
    <li class="mono"><a href="#main.hobby_intent">hobby_intent</a></li>
    <li class="mono"><a href="#main.launch">launch</a></li>
    <li class="mono"><a href="#main.make_call_to_myalfred_api">make_call_to_myalfred_api</a></li>
    <li class="mono"><a href="#main.message_account_linking">message_account_linking</a></li>
    <li class="mono"><a href="#main.message_duration_intent">message_duration_intent</a></li>
    <li class="mono"><a href="#main.message_hobby_intent">message_hobby_intent</a></li>
    <li class="mono"><a href="#main.message_success">message_success</a></li>
    <li class="mono"><a href="#main.message_time_of_day_intent">message_time_of_day_intent</a></li>
    <li class="mono"><a href="#main.message_when_intent">message_when_intent</a></li>
    <li class="mono"><a href="#main.next_weekday">next_weekday</a></li>
    <li class="mono"><a href="#main.set_request">set_request</a></li>
    <li class="mono"><a href="#main.stop">stop</a></li>
    <li class="mono"><a href="#main.when_intent">when_intent</a></li>
  </ul>

    </li>


    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">main</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main', this);">Show source &equiv;</a></p>
  <div id="source-main" class="source">
    <pre><code># -*- coding: utf-8 -*-
import logging
import datetime
import pprint
import json
import requests
from requests.auth import HTTPBasicAuth
from flask import Flask
from flask_ask import Ask, session, question, statement, request

app = Flask(__name__)
ask = Ask(app, "/")
logger = logging.getLogger()


# ---------------------------------------------------------------------------------------------- INTENTS

@ask.launch
def launch():
    """
    Launch event, which is called when user says 'start/open myalfred' Welcomes user, if account is linked. If 
    account is not linked, Alexa will say that there was an error and that the user should have a look into his 
    companion app to link skill (again). Furthermore, it will create a LinkedCard for the companion app so that user 
    has an easy way to link skill. :return: question, what user wants to do -> HobbyIntent. Or statement with linked 
    card when skill isn't linked. 
    """
    if account_is_linked():
        if str(request.locale) == "de-DE":
            return question("Hallo, ich bin mei-Alfred. Was kann ich für dich tun?").reprompt(
                "Du könntest zum Beispiel sagen 'Ich möchte lernen'.")
        else:
            return question("Hey, what can I do for you?").reprompt("You could for example say: 'I want to study'.")
    else:
        return message_account_linking()


@ask.intent('HobbyIntent', mapping={'hobby': 'Hobby'})
def hobby_intent(hobby):
    """
    This event is called whenever Alexa recognizes the 'HobbyIntent'. It checks token-availability too, 
    because sometimes user will skip the launch event. If account is not linked, Alexa will say that there was an 
    error and that the user should have a look into his companion app to link skill (again). Furthermore, 
    it will create a LinkedCard for the companion app so that user has an easy way to link skill. :param hobby: 
    mapped 'Hobby' slot value, f. e. "go running" :return: question when user wants to do his/her hobby -> 
    WhenIntent. Or statement with linked card when skill isn't linked. 
    """
    session.attributes['hobby'] = hobby
    return message_hobby_intent()


@ask.intent('WhenIntent', mapping={'when': 'When'})
def when_intent(when):
    """
    This event is called whenever Alexa recognizes the 'WhenIntent'.
    Checks which slot value (i.e. "this week", "next month",...) was called 
    and calculates milliseconds for start and end date in json for myalfred-api-call.
    :param when: mapped 'When' slot value, i.e. "this week"
    :return: question, how long user think this event will be -> TimeDurationIntent
    """

    if session.attributes.hobby is not None:
        return message_hobby_intent()


    global start_milliseconds, end_milliseconds
    today = datetime.datetime.now()
    when = str(when).lower()

    if when == "this week" or when == "diese woche":
        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        this_sunday = next_weekday(today, 0)
        end_milliseconds = (this_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "next week" or when == "nächste woche":
        next_monday = next_weekday(today, 0)
        next_sunday = next_weekday(next_monday, 0)

        start_milliseconds = (next_monday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (next_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "this weekend" or when == "dieses wochenende":
        this_friday = next_weekday(today, 4)
        this_sunday = next_weekday(this_friday, 0)

        start_milliseconds = (this_friday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (this_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "next weekend" or when == "nächstes wochenende":
        this_sunday = next_weekday(today, 6)
        next_friday = next_weekday(this_sunday, 4)
        next_sunday = next_weekday(next_friday, 0)

        start_milliseconds = (next_friday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (next_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "this month" or when == "dieses monat":
        last_of_month = get_last_of_month(today)

        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "next month" or when == "nächstes monat":
        first_of_month = datetime.datetime(today.year, (today.month + 1), 1)
        last_of_month = get_last_of_month(first_of_month)

        start_milliseconds = (first_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "this year" or when == "dieses jahr":
        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (
                               datetime.datetime(today.year, 12, 31) - datetime.datetime(1970, 1,
                                                                                         1)).total_seconds() * 1000

    elif when == "next year" or when == "nächstes jahr":
        start_milliseconds = (datetime.datetime(today.year + 1, 1, 1) - datetime.datetime(1970, 1,
                                                                                          1)).total_seconds() * 1000
        end_milliseconds = (datetime.datetime(today.year + 1, 12, 31) - datetime.datetime(1970, 1,
                                                                                          1)).total_seconds() * 1000

    session.attributes['when_start'] = int(start_milliseconds)
    session.attributes['when_end'] = int(end_milliseconds)

    pprint.pprint(str(when))

    return message_when_intent()


@ask.intent('TimeDurationIntent', mapping={'timeduration': 'TimeDuration'})
def convert_to_seconds_from(timeduration):
    """
    This event is called whenever Alexa recognizes the 'TimeDurationIntent'.
    Checks slot value, which must be a time reference in ISO-8601 duration format.
    Calculates duartion in millicseconds for json for myalfred-api-call.
    :param timeduration:  mapped 'TimeDuration' slot value, i.e. "PT1H" -> one hour
    :return: question, at which time of the day the event should take place in -> TimeOfDayIntent
    """

    if session.attributes.hobby is not None:
        return message_when_intent()

    # PnYnMnWnDTnHnMnS
    global days, seconds
    string = str(timeduration)
    iso = string[1:]
    length = len(iso)

    if length == 0:
        if str(request.locale) == "de-DE":
            return question("Leider hatte ich ein Problem die Zeitspanne zu berechnen. Wie lange wirst du brauchen?")
        else:
            return question(
                "Something went wrong with calculating the time duration. Please try again. How long will it take you?")

    if iso[0] is not 'T':
        index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'Y':
            years = iso[0:index]
            days = int(years) * 365

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'M':
            months = iso[0:index]
            days += int(months) * 30

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'W':
            weeks = iso[0:index]
            days += int(weeks) * 7

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'D':
            days_str = iso[0:index]
            days += int(days_str)

            iso = iso[index + 1:]

        seconds = days * 24 * 3600

    if iso[0] is 'T':

        iso = iso[1:]
        index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'H':
            hours = iso[0:index]
            seconds = (int(hours) * 3600)

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'M':
            minutes = iso[0:index]
            seconds = (int(minutes) * 60)

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'S':
            seconds_str = iso[0:index]
            seconds = (int(seconds_str))

    milliseconds = seconds * 1000
    session.attributes['duration'] = milliseconds
    pprint.pprint(timeduration)

    return message_duration_intent()


@ask.intent('TimeOfDayIntent', mapping={'time': 'TimeOfDay'})
def get_time_of_day(time):
    """
    This event is called whenever Alexa recognizes the 'TimeOfDayIntent'.
    Checks slot value (i.e. "morning", "evening", ...) and calculates start and end hours for json for myalfred api call.
    :param time: mapped 'TimeOfDay' slot value
    :return: question, how often the event should be scheduled -> PeriodIntent
    """

    if session.attributes.hobby is not None:
        return message_duration_intent()

    global starthours, endhours
    if time == "morning" or time == "morgen" or time == "vormittag":
        starthours = 5
        endhours = 11

    elif time == "midday" or time == "mittag":
        starthours = 10
        endhours = 14

    elif time == "afternoon" or time == "nachmittag":
        starthours = 13
        endhours = 18

    elif time == "evening" or time == "abend":
        starthours = 17
        endhours = 22

    elif time == "night" or time == "nacht":
        starthours = 21
        endhours = 5

    session.attributes['daytime_start'] = starthours
    session.attributes['daytime_end'] = endhours
    pprint.pprint(time)

    return message_time_of_day_intent()


@ask.intent('PeriodIntent', mapping={'period': 'Period'})
def get_time_of_day(period):
    """
       This event is called whenever Alexa recognizes the 'PeriodIntent'.
       Checks slot value (i.e. "daily", "weekly", "not at all"...) 
       and calculates number for repeat period for json for myalfred api call.
       Afterwards, calls set_request, which is calling the myalfred api with our input data.
       If call was successfull, Alexa will reply that the event was created. 
       Otherwise, Alexa will tell the user that something went wrong.
       :param period: mapped 'Period' slot value
       :return: statement, which declares if the call was successfull or not
    """
    if session.attributes.hobby is not None:
        return message_time_of_day_intent()

    repeat = ""
    if period is "daily" or period is "täglich":
        repeat = 5
    elif period is "weekly" or period is "wöchentlich":
        repeat = 6
    elif period is "yearly" or period is "jährlich":
        repeat = 7
    else:
        set_request()

    session.attributes['period'] = repeat
    pprint.pprint(period)
    return set_request()


# ------------------------------------------------------------------------------------------- AMAZON.Intents

@ask.intent('AMAZON.StopIntent')
def stop():
    """
    This event is called whenever Alexa recognizes the 'AMAZON.StopIntent'.
    Ends skill
    :return: statement with send-off
    """
    if str(request.locale) is "de-DE":
        return statement("OK. Noch einen schönen Tag!")
    else:
        return statement("OK. Have a nice day. Hope to see you soon!")


# ---------------------------------------------------------------------------------------------- used FUNCTIONS


def next_weekday(day, weekday):
    """
    Calculates next upcoming day, that is described in param 'weekday' (weekday = 0 Monday, = 1 Tuesday,...)
    :param day: daytime object, that describes current day
    :param weekday: integer, that describes which upcoming day of the week should be searched for
    :return: datetime object, that describes wanted upcoming day.
    """

    d = day.replace(hour=0, minute=0, second=0)
    days_ahead = weekday - d.weekday()

    if days_ahead <= 0:
        days_ahead += 7

    return d + datetime.timedelta(days_ahead)


def get_index_where_next_char_occurs(iso):
    """
    Calculates next index where a character is situated.
    i.e. 01234A -> index 5
    :param iso: string
    :return: index position
    """
    if iso is '':
        return None

    i = 0
    numbers = '0123456789'

    for char in iso:
        if char not in numbers:
            return i
        i += 1

    return None


def account_is_linked():
    """
    Checks if session includes an accesstoken or not
    :return: True, if accesstoken exists. False if not
    """
    if session.user.accessToken is not None:
        return True
    else:
        return False


def get_last_of_month(first_of_month):
    """
    Creates datetime object, which is the last day in 'first_of_month.month'
    :param first_of_month: defines month in which the datetime object should be in
    :return: datetime object
    """
    global last_of_month
    if first_of_month.month in {1, 3, 5, 7, 8, 10, 12}:
        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 31)

    elif first_of_month in {4, 6, 9, 11}:
        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 30)

    elif first_of_month is 2:
        if first_of_month.year % 4 is 0:
            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 29)
        else:
            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 28)

    return last_of_month


def set_request():
    """
    Prepares JSON Object for our API call.
    Retrieves all data, that was stored into our session, and saves it into a json object.
    Afterwards, calls myalfred make_call_to_myalfred_api with mentioned json object.
    :return: 
    """

    token = session.user.accessToken
    hobby = session.attributes.hobby
    when_start = session.attributes.when_start
    when_end = session.attributes.when_end
    duration = session.attributes.duration
    daytime_start = session.attributes.daytime_start
    daytime_end = session.attributes.daytime_end

    pprint.pprint(str(token) + "   hobby: " + str(hobby))

    if session.attributes.period is not None and session.attributes.period is not "":
        is_repeating = True
        period = session.attributes.period
    else:
        is_repeating = False
        period = 0

    call = {
        # Get token from https://developers.google.com/oauthplayground/
        "accessTokens": [str(token)],
        "eventTitle": str(hobby),
        "start": int(float(when_start)),
        "end": int(float(when_end)),
        "eventDuration": int(float(duration)),
        "originatorId": "alexa-skill",
        "startRanges": [
            {
                "startHours": int(float(daytime_start)),
                "startMinutes": 0,
                "endHours": int(float(daytime_end)),
                "endMinutes": 0,
                "timeZone": "Europe/Vienna"
            }
        ],
        "location": {
            "type": "Location",
            "name": "",
            "coordinates": {
                "lat": 48.244179,
                "lng": 14.23592
            },
            "address": None
        },
        "count": 1,
        "isRepeating": is_repeating,
        "repeatPeriod": int(period),
        "repeatInterval": 1
    }

    return make_call_to_myalfred_api(call)

    # return state
    #
    #
    #     return statement("I have successfully found a date for you. I have saved it into your calendar.")


def make_call_to_myalfred_api(json_data):
    """
    Makes a POST-request to the myAlfred Scheduling API using a JSON object
    containing Google Calendar token & desired scheduling setup and returns the response body.

    :param json_data: the json request containing all relevant information about a desired event
    :return: The response body of the scheduling api
    """
    url = 'https://staging.myalfred.io/api/schedule/google'
    try:
        r = requests.post(url, auth=HTTPBasicAuth('AmazonAlexaClient', '7m33P2K7tYhcgKNvNpd747pRFfo9H8'),
                          json=json_data, timeout=None)
        data = json.loads(r.text)
        pprint.pprint(r.text)
    except requests.exceptions.HTTPError as err:
        print err
        return statement("error")
    except requests.exceptions.Timeout:
        pprint.pprint("try again")
        make_call_to_myalfred_api(json_data)
    except requests.exceptions.TooManyRedirects:
        pprint.pprint("bad url")
        return statement("error")
    except requests.exceptions.RequestException as e:
        pprint.pprint("really bad error..")
        print e
        return statement("error")
    except Exception:
        pprint.pprint("exception all..")
        return statement("error")

    return message_success()

    #start_date = convert_to_datetime_from_milliseconds(data['startDate'])
    #pprint.pprint()

    # if (str(request.locale) == "de-DE"):
    #     return statement("Ich habe dir den Termin erfolgreich eingetragen. Er findet am {} um {} Uhr statt.".format(start_date.date, start_date.time))
    # else:
    #     return statement("Ich have successfully added the event to your calendar. The date is at {} at {}".format(start_date.date, start_date.time))


def convert_to_datetime_from_milliseconds(milliseconds):
    """
    Converts milliseconds to datetime object
    :param milliseconds: int
    :return: datetime object
    """
    return datetime.datetime.fromtimestamp(milliseconds / 1000.0)


# ------------------------------------------------------------------------------------------- Return Messages

def message_account_linking():
    """
    Returns statement, that the account is not linked. Adds specific linking card.
    :return: statement
    """
    if str(request.locale) == "de-DE":
        return statement(
            "Leider hatte ich ein Problem mich mit deinem Kalender zu verbinden. Bitte siehe in deinen"
            "Einstellungen nach, ob du mich mit dem Kalender verknüpft hast.").link_account_card()
    else:
        return statement(
            "There was a problem regarding your linked calendar settings to your myalfred skill. "
            "Please have a look into your companion app to check the status.").link_account_card()


def message_hobby_intent():
    """
    If account is linked, returns question, when the user wants to do this event
    If not linked, returns 'message_account_linking'
    :return: question or statement
    """
    if account_is_linked():
        if str(request.locale) == "de-DE":
            return question("OK! Wann möchtest du das machen?").reprompt(
                "Du könntest zum Beispiel sagen 'nächste Woche'.")
        else:
            return question("OK! When do you want to do it?").reprompt(
                "You could choose for example: 'this week' or 'next month")
    else:
        return message_account_linking()


def message_when_intent():
    """
    Returns question, how long user will need to finish event.
    :return: question
    """
    if str(request.locale) == "de-DE":
        return question("Wie lange wirst du dafür brauchen?").reprompt(
            "Du könntest zum Beispiel sagen 'Zwei Stunden wird es dauern'.")
    else:
        return question("How long will it take you?").reprompt("You could for example say 'it will take 2 hours'.")


def message_duration_intent():
    """
    Returns question, at what time of the day the user wants to do the event
    :return: question
    """
    if str(request.locale) == "de-DE":
        return question("OK. Zu welcher ungefähren Tageszeit möchtest du es machen?").reprompt(
            "Du könntest zum Beispiel sagen 'am Nachmittag'.")
    else:
        return question("OK. At what time of the day do you want to do it?").reprompt(
            "You could for example say 'in the afternoon'.")


def message_time_of_day_intent():
    """
    Returns question, if event should repeat itself
    :return: question
    """
    if str(request.locale) == "de-DE":
        return question("Soll sich der Termin täglich, wöchentlich, jährlich oder gar nicht wiederholen?").reprompt(
            "Du könntest zum Beispiel sagen 'es soll sich gar nicht wiederholen'.")
    else:
        return question("Should the event repeat itself daily, weekly, yearly or not at all?").reprompt(
            "You could for example say 'it should repeat not at all'.")


def message_success():
    """
    Returns statement, that the creating was a success
    :return: statement
    """
    if (str(request.locale) == "de-DE"):
        return statement(
            "Ich habe dir den Termin erfolgreich eingetragen")
    else:
        return statement(
            "Ich have successfully added the event to your calendar")


if __name__ == "__main__":
    app.run(debug=True)
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="main.app" class="name">var <span class="ident">app</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="main.ask" class="name">var <span class="ident">ask</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="main.logger" class="name">var <span class="ident">logger</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="main.account_is_linked">
    <p>def <span class="ident">account_is_linked</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Checks if session includes an accesstoken or not
:return: True, if accesstoken exists. False if not</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.account_is_linked', this);">Show source &equiv;</a></p>
  <div id="source-main.account_is_linked" class="source">
    <pre><code>def account_is_linked():
    """
    Checks if session includes an accesstoken or not
    :return: True, if accesstoken exists. False if not
    """
    if session.user.accessToken is not None:
        return True
    else:
        return False
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.convert_to_datetime_from_milliseconds">
    <p>def <span class="ident">convert_to_datetime_from_milliseconds</span>(</p><p>milliseconds)</p>
    </div>
    

    
  
    <div class="desc"><p>Converts milliseconds to datetime object
:param milliseconds: int
:return: datetime object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.convert_to_datetime_from_milliseconds', this);">Show source &equiv;</a></p>
  <div id="source-main.convert_to_datetime_from_milliseconds" class="source">
    <pre><code>def convert_to_datetime_from_milliseconds(milliseconds):
    """
    Converts milliseconds to datetime object
    :param milliseconds: int
    :return: datetime object
    """
    return datetime.datetime.fromtimestamp(milliseconds / 1000.0)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.convert_to_seconds_from">
    <p>def <span class="ident">convert_to_seconds_from</span>(</p><p>timeduration)</p>
    </div>
    

    
  
    <div class="desc"><p>This event is called whenever Alexa recognizes the 'TimeDurationIntent'.
Checks slot value, which must be a time reference in ISO-8601 duration format.
Calculates duartion in millicseconds for json for myalfred-api-call.
:param timeduration:  mapped 'TimeDuration' slot value, i.e. "PT1H" -&gt; one hour
:return: question, at which time of the day the event should take place in -&gt; TimeOfDayIntent</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.convert_to_seconds_from', this);">Show source &equiv;</a></p>
  <div id="source-main.convert_to_seconds_from" class="source">
    <pre><code>@ask.intent('TimeDurationIntent', mapping={'timeduration': 'TimeDuration'})
def convert_to_seconds_from(timeduration):
    """
    This event is called whenever Alexa recognizes the 'TimeDurationIntent'.
    Checks slot value, which must be a time reference in ISO-8601 duration format.
    Calculates duartion in millicseconds for json for myalfred-api-call.
    :param timeduration:  mapped 'TimeDuration' slot value, i.e. "PT1H" -> one hour
    :return: question, at which time of the day the event should take place in -> TimeOfDayIntent
    """

    if session.attributes.hobby is not None:
        return message_when_intent()

    # PnYnMnWnDTnHnMnS
    global days, seconds
    string = str(timeduration)
    iso = string[1:]
    length = len(iso)

    if length == 0:
        if str(request.locale) == "de-DE":
            return question("Leider hatte ich ein Problem die Zeitspanne zu berechnen. Wie lange wirst du brauchen?")
        else:
            return question(
                "Something went wrong with calculating the time duration. Please try again. How long will it take you?")

    if iso[0] is not 'T':
        index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'Y':
            years = iso[0:index]
            days = int(years) * 365

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'M':
            months = iso[0:index]
            days += int(months) * 30

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'W':
            weeks = iso[0:index]
            days += int(weeks) * 7

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'D':
            days_str = iso[0:index]
            days += int(days_str)

            iso = iso[index + 1:]

        seconds = days * 24 * 3600

    if iso[0] is 'T':

        iso = iso[1:]
        index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'H':
            hours = iso[0:index]
            seconds = (int(hours) * 3600)

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'M':
            minutes = iso[0:index]
            seconds = (int(minutes) * 60)

            iso = iso[index + 1:]
            index = get_index_where_next_char_occurs(iso)

        if index is not None and iso[index] is 'S':
            seconds_str = iso[0:index]
            seconds = (int(seconds_str))

    milliseconds = seconds * 1000
    session.attributes['duration'] = milliseconds
    pprint.pprint(timeduration)

    return message_duration_intent()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.get_index_where_next_char_occurs">
    <p>def <span class="ident">get_index_where_next_char_occurs</span>(</p><p>iso)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates next index where a character is situated.
i.e. 01234A -&gt; index 5
:param iso: string
:return: index position</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.get_index_where_next_char_occurs', this);">Show source &equiv;</a></p>
  <div id="source-main.get_index_where_next_char_occurs" class="source">
    <pre><code>def get_index_where_next_char_occurs(iso):
    """
    Calculates next index where a character is situated.
    i.e. 01234A -> index 5
    :param iso: string
    :return: index position
    """
    if iso is '':
        return None

    i = 0
    numbers = '0123456789'

    for char in iso:
        if char not in numbers:
            return i
        i += 1

    return None
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.get_last_of_month">
    <p>def <span class="ident">get_last_of_month</span>(</p><p>first_of_month)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates datetime object, which is the last day in 'first_of_month.month'
:param first_of_month: defines month in which the datetime object should be in
:return: datetime object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.get_last_of_month', this);">Show source &equiv;</a></p>
  <div id="source-main.get_last_of_month" class="source">
    <pre><code>def get_last_of_month(first_of_month):
    """
    Creates datetime object, which is the last day in 'first_of_month.month'
    :param first_of_month: defines month in which the datetime object should be in
    :return: datetime object
    """
    global last_of_month
    if first_of_month.month in {1, 3, 5, 7, 8, 10, 12}:
        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 31)

    elif first_of_month in {4, 6, 9, 11}:
        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 30)

    elif first_of_month is 2:
        if first_of_month.year % 4 is 0:
            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 29)
        else:
            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 28)

    return last_of_month
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.get_time_of_day">
    <p>def <span class="ident">get_time_of_day</span>(</p><p>period)</p>
    </div>
    

    
  
    <div class="desc"><p>This event is called whenever Alexa recognizes the 'PeriodIntent'.
Checks slot value (i.e. "daily", "weekly", "not at all"...) 
and calculates number for repeat period for json for myalfred api call.
Afterwards, calls set_request, which is calling the myalfred api with our input data.
If call was successfull, Alexa will reply that the event was created. 
Otherwise, Alexa will tell the user that something went wrong.
:param period: mapped 'Period' slot value
:return: statement, which declares if the call was successfull or not</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.get_time_of_day', this);">Show source &equiv;</a></p>
  <div id="source-main.get_time_of_day" class="source">
    <pre><code>@ask.intent('PeriodIntent', mapping={'period': 'Period'})
def get_time_of_day(period):
    """
       This event is called whenever Alexa recognizes the 'PeriodIntent'.
       Checks slot value (i.e. "daily", "weekly", "not at all"...) 
       and calculates number for repeat period for json for myalfred api call.
       Afterwards, calls set_request, which is calling the myalfred api with our input data.
       If call was successfull, Alexa will reply that the event was created. 
       Otherwise, Alexa will tell the user that something went wrong.
       :param period: mapped 'Period' slot value
       :return: statement, which declares if the call was successfull or not
    """
    if session.attributes.hobby is not None:
        return message_time_of_day_intent()

    repeat = ""
    if period is "daily" or period is "täglich":
        repeat = 5
    elif period is "weekly" or period is "wöchentlich":
        repeat = 6
    elif period is "yearly" or period is "jährlich":
        repeat = 7
    else:
        set_request()

    session.attributes['period'] = repeat
    pprint.pprint(period)
    return set_request()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.hobby_intent">
    <p>def <span class="ident">hobby_intent</span>(</p><p>hobby)</p>
    </div>
    

    
  
    <div class="desc"><p>This event is called whenever Alexa recognizes the 'HobbyIntent'. It checks token-availability too, 
because sometimes user will skip the launch event. If account is not linked, Alexa will say that there was an 
error and that the user should have a look into his companion app to link skill (again). Furthermore, 
it will create a LinkedCard for the companion app so that user has an easy way to link skill. :param hobby: 
mapped 'Hobby' slot value, f. e. "go running" :return: question when user wants to do his/her hobby -&gt; 
WhenIntent. Or statement with linked card when skill isn't linked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.hobby_intent', this);">Show source &equiv;</a></p>
  <div id="source-main.hobby_intent" class="source">
    <pre><code>@ask.intent('HobbyIntent', mapping={'hobby': 'Hobby'})
def hobby_intent(hobby):
    """
    This event is called whenever Alexa recognizes the 'HobbyIntent'. It checks token-availability too, 
    because sometimes user will skip the launch event. If account is not linked, Alexa will say that there was an 
    error and that the user should have a look into his companion app to link skill (again). Furthermore, 
    it will create a LinkedCard for the companion app so that user has an easy way to link skill. :param hobby: 
    mapped 'Hobby' slot value, f. e. "go running" :return: question when user wants to do his/her hobby -> 
    WhenIntent. Or statement with linked card when skill isn't linked. 
    """
    session.attributes['hobby'] = hobby
    return message_hobby_intent()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.launch">
    <p>def <span class="ident">launch</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Launch event, which is called when user says 'start/open myalfred' Welcomes user, if account is linked. If 
account is not linked, Alexa will say that there was an error and that the user should have a look into his 
companion app to link skill (again). Furthermore, it will create a LinkedCard for the companion app so that user 
has an easy way to link skill. :return: question, what user wants to do -&gt; HobbyIntent. Or statement with linked 
card when skill isn't linked.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.launch', this);">Show source &equiv;</a></p>
  <div id="source-main.launch" class="source">
    <pre><code>@ask.launch
def launch():
    """
    Launch event, which is called when user says 'start/open myalfred' Welcomes user, if account is linked. If 
    account is not linked, Alexa will say that there was an error and that the user should have a look into his 
    companion app to link skill (again). Furthermore, it will create a LinkedCard for the companion app so that user 
    has an easy way to link skill. :return: question, what user wants to do -> HobbyIntent. Or statement with linked 
    card when skill isn't linked. 
    """
    if account_is_linked():
        if str(request.locale) == "de-DE":
            return question("Hallo, ich bin mei-Alfred. Was kann ich für dich tun?").reprompt(
                "Du könntest zum Beispiel sagen 'Ich möchte lernen'.")
        else:
            return question("Hey, what can I do for you?").reprompt("You could for example say: 'I want to study'.")
    else:
        return message_account_linking()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.make_call_to_myalfred_api">
    <p>def <span class="ident">make_call_to_myalfred_api</span>(</p><p>json_data)</p>
    </div>
    

    
  
    <div class="desc"><p>Makes a POST-request to the myAlfred Scheduling API using a JSON object
containing Google Calendar token &amp; desired scheduling setup and returns the response body.</p>
<p>:param json_data: the json request containing all relevant information about a desired event
:return: The response body of the scheduling api</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.make_call_to_myalfred_api', this);">Show source &equiv;</a></p>
  <div id="source-main.make_call_to_myalfred_api" class="source">
    <pre><code>def make_call_to_myalfred_api(json_data):
    """
    Makes a POST-request to the myAlfred Scheduling API using a JSON object
    containing Google Calendar token & desired scheduling setup and returns the response body.

    :param json_data: the json request containing all relevant information about a desired event
    :return: The response body of the scheduling api
    """
    url = 'https://staging.myalfred.io/api/schedule/google'
    try:
        r = requests.post(url, auth=HTTPBasicAuth('AmazonAlexaClient', '7m33P2K7tYhcgKNvNpd747pRFfo9H8'),
                          json=json_data, timeout=None)
        data = json.loads(r.text)
        pprint.pprint(r.text)
    except requests.exceptions.HTTPError as err:
        print err
        return statement("error")
    except requests.exceptions.Timeout:
        pprint.pprint("try again")
        make_call_to_myalfred_api(json_data)
    except requests.exceptions.TooManyRedirects:
        pprint.pprint("bad url")
        return statement("error")
    except requests.exceptions.RequestException as e:
        pprint.pprint("really bad error..")
        print e
        return statement("error")
    except Exception:
        pprint.pprint("exception all..")
        return statement("error")

    return message_success()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.message_account_linking">
    <p>def <span class="ident">message_account_linking</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns statement, that the account is not linked. Adds specific linking card.
:return: statement</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.message_account_linking', this);">Show source &equiv;</a></p>
  <div id="source-main.message_account_linking" class="source">
    <pre><code>def message_account_linking():
    """
    Returns statement, that the account is not linked. Adds specific linking card.
    :return: statement
    """
    if str(request.locale) == "de-DE":
        return statement(
            "Leider hatte ich ein Problem mich mit deinem Kalender zu verbinden. Bitte siehe in deinen"
            "Einstellungen nach, ob du mich mit dem Kalender verknüpft hast.").link_account_card()
    else:
        return statement(
            "There was a problem regarding your linked calendar settings to your myalfred skill. "
            "Please have a look into your companion app to check the status.").link_account_card()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.message_duration_intent">
    <p>def <span class="ident">message_duration_intent</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns question, at what time of the day the user wants to do the event
:return: question</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.message_duration_intent', this);">Show source &equiv;</a></p>
  <div id="source-main.message_duration_intent" class="source">
    <pre><code>def message_duration_intent():
    """
    Returns question, at what time of the day the user wants to do the event
    :return: question
    """
    if str(request.locale) == "de-DE":
        return question("OK. Zu welcher ungefähren Tageszeit möchtest du es machen?").reprompt(
            "Du könntest zum Beispiel sagen 'am Nachmittag'.")
    else:
        return question("OK. At what time of the day do you want to do it?").reprompt(
            "You could for example say 'in the afternoon'.")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.message_hobby_intent">
    <p>def <span class="ident">message_hobby_intent</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>If account is linked, returns question, when the user wants to do this event
If not linked, returns 'message_account_linking'
:return: question or statement</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.message_hobby_intent', this);">Show source &equiv;</a></p>
  <div id="source-main.message_hobby_intent" class="source">
    <pre><code>def message_hobby_intent():
    """
    If account is linked, returns question, when the user wants to do this event
    If not linked, returns 'message_account_linking'
    :return: question or statement
    """
    if account_is_linked():
        if str(request.locale) == "de-DE":
            return question("OK! Wann möchtest du das machen?").reprompt(
                "Du könntest zum Beispiel sagen 'nächste Woche'.")
        else:
            return question("OK! When do you want to do it?").reprompt(
                "You could choose for example: 'this week' or 'next month")
    else:
        return message_account_linking()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.message_success">
    <p>def <span class="ident">message_success</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns statement, that the creating was a success
:return: statement</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.message_success', this);">Show source &equiv;</a></p>
  <div id="source-main.message_success" class="source">
    <pre><code>def message_success():
    """
    Returns statement, that the creating was a success
    :return: statement
    """
    if (str(request.locale) == "de-DE"):
        return statement(
            "Ich habe dir den Termin erfolgreich eingetragen")
    else:
        return statement(
            "Ich have successfully added the event to your calendar")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.message_time_of_day_intent">
    <p>def <span class="ident">message_time_of_day_intent</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns question, if event should repeat itself
:return: question</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.message_time_of_day_intent', this);">Show source &equiv;</a></p>
  <div id="source-main.message_time_of_day_intent" class="source">
    <pre><code>def message_time_of_day_intent():
    """
    Returns question, if event should repeat itself
    :return: question
    """
    if str(request.locale) == "de-DE":
        return question("Soll sich der Termin täglich, wöchentlich, jährlich oder gar nicht wiederholen?").reprompt(
            "Du könntest zum Beispiel sagen 'es soll sich gar nicht wiederholen'.")
    else:
        return question("Should the event repeat itself daily, weekly, yearly or not at all?").reprompt(
            "You could for example say 'it should repeat not at all'.")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.message_when_intent">
    <p>def <span class="ident">message_when_intent</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns question, how long user will need to finish event.
:return: question</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.message_when_intent', this);">Show source &equiv;</a></p>
  <div id="source-main.message_when_intent" class="source">
    <pre><code>def message_when_intent():
    """
    Returns question, how long user will need to finish event.
    :return: question
    """
    if str(request.locale) == "de-DE":
        return question("Wie lange wirst du dafür brauchen?").reprompt(
            "Du könntest zum Beispiel sagen 'Zwei Stunden wird es dauern'.")
    else:
        return question("How long will it take you?").reprompt("You could for example say 'it will take 2 hours'.")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.next_weekday">
    <p>def <span class="ident">next_weekday</span>(</p><p>day, weekday)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculates next upcoming day, that is described in param 'weekday' (weekday = 0 Monday, = 1 Tuesday,...)
:param day: daytime object, that describes current day
:param weekday: integer, that describes which upcoming day of the week should be searched for
:return: datetime object, that describes wanted upcoming day.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.next_weekday', this);">Show source &equiv;</a></p>
  <div id="source-main.next_weekday" class="source">
    <pre><code>def next_weekday(day, weekday):
    """
    Calculates next upcoming day, that is described in param 'weekday' (weekday = 0 Monday, = 1 Tuesday,...)
    :param day: daytime object, that describes current day
    :param weekday: integer, that describes which upcoming day of the week should be searched for
    :return: datetime object, that describes wanted upcoming day.
    """

    d = day.replace(hour=0, minute=0, second=0)
    days_ahead = weekday - d.weekday()

    if days_ahead <= 0:
        days_ahead += 7

    return d + datetime.timedelta(days_ahead)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.set_request">
    <p>def <span class="ident">set_request</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Prepares JSON Object for our API call.
Retrieves all data, that was stored into our session, and saves it into a json object.
Afterwards, calls myalfred make_call_to_myalfred_api with mentioned json object.
:return:</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.set_request', this);">Show source &equiv;</a></p>
  <div id="source-main.set_request" class="source">
    <pre><code>def set_request():
    """
    Prepares JSON Object for our API call.
    Retrieves all data, that was stored into our session, and saves it into a json object.
    Afterwards, calls myalfred make_call_to_myalfred_api with mentioned json object.
    :return: 
    """

    token = session.user.accessToken
    hobby = session.attributes.hobby
    when_start = session.attributes.when_start
    when_end = session.attributes.when_end
    duration = session.attributes.duration
    daytime_start = session.attributes.daytime_start
    daytime_end = session.attributes.daytime_end

    pprint.pprint(str(token) + "   hobby: " + str(hobby))

    if session.attributes.period is not None and session.attributes.period is not "":
        is_repeating = True
        period = session.attributes.period
    else:
        is_repeating = False
        period = 0

    call = {
        # Get token from https://developers.google.com/oauthplayground/
        "accessTokens": [str(token)],
        "eventTitle": str(hobby),
        "start": int(float(when_start)),
        "end": int(float(when_end)),
        "eventDuration": int(float(duration)),
        "originatorId": "alexa-skill",
        "startRanges": [
            {
                "startHours": int(float(daytime_start)),
                "startMinutes": 0,
                "endHours": int(float(daytime_end)),
                "endMinutes": 0,
                "timeZone": "Europe/Vienna"
            }
        ],
        "location": {
            "type": "Location",
            "name": "",
            "coordinates": {
                "lat": 48.244179,
                "lng": 14.23592
            },
            "address": None
        },
        "count": 1,
        "isRepeating": is_repeating,
        "repeatPeriod": int(period),
        "repeatInterval": 1
    }

    return make_call_to_myalfred_api(call)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.stop">
    <p>def <span class="ident">stop</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>This event is called whenever Alexa recognizes the 'AMAZON.StopIntent'.
Ends skill
:return: statement with send-off</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.stop', this);">Show source &equiv;</a></p>
  <div id="source-main.stop" class="source">
    <pre><code>@ask.intent('AMAZON.StopIntent')
def stop():
    """
    This event is called whenever Alexa recognizes the 'AMAZON.StopIntent'.
    Ends skill
    :return: statement with send-off
    """
    if str(request.locale) is "de-DE":
        return statement("OK. Noch einen schönen Tag!")
    else:
        return statement("OK. Have a nice day. Hope to see you soon!")
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="main.when_intent">
    <p>def <span class="ident">when_intent</span>(</p><p>when)</p>
    </div>
    

    
  
    <div class="desc"><p>This event is called whenever Alexa recognizes the 'WhenIntent'.
Checks which slot value (i.e. "this week", "next month",...) was called 
and calculates milliseconds for start and end date in json for myalfred-api-call.
:param when: mapped 'When' slot value, i.e. "this week"
:return: question, how long user think this event will be -&gt; TimeDurationIntent</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-main.when_intent', this);">Show source &equiv;</a></p>
  <div id="source-main.when_intent" class="source">
    <pre><code>@ask.intent('WhenIntent', mapping={'when': 'When'})
def when_intent(when):
    """
    This event is called whenever Alexa recognizes the 'WhenIntent'.
    Checks which slot value (i.e. "this week", "next month",...) was called 
    and calculates milliseconds for start and end date in json for myalfred-api-call.
    :param when: mapped 'When' slot value, i.e. "this week"
    :return: question, how long user think this event will be -> TimeDurationIntent
    """

    if session.attributes.hobby is not None:
        return message_hobby_intent()


    global start_milliseconds, end_milliseconds
    today = datetime.datetime.now()
    when = str(when).lower()

    if when == "this week" or when == "diese woche":
        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        this_sunday = next_weekday(today, 0)
        end_milliseconds = (this_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "next week" or when == "nächste woche":
        next_monday = next_weekday(today, 0)
        next_sunday = next_weekday(next_monday, 0)

        start_milliseconds = (next_monday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (next_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "this weekend" or when == "dieses wochenende":
        this_friday = next_weekday(today, 4)
        this_sunday = next_weekday(this_friday, 0)

        start_milliseconds = (this_friday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (this_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "next weekend" or when == "nächstes wochenende":
        this_sunday = next_weekday(today, 6)
        next_friday = next_weekday(this_sunday, 4)
        next_sunday = next_weekday(next_friday, 0)

        start_milliseconds = (next_friday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (next_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "this month" or when == "dieses monat":
        last_of_month = get_last_of_month(today)

        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "next month" or when == "nächstes monat":
        first_of_month = datetime.datetime(today.year, (today.month + 1), 1)
        last_of_month = get_last_of_month(first_of_month)

        start_milliseconds = (first_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000

    elif when == "this year" or when == "dieses jahr":
        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000
        end_milliseconds = (
                               datetime.datetime(today.year, 12, 31) - datetime.datetime(1970, 1,
                                                                                         1)).total_seconds() * 1000

    elif when == "next year" or when == "nächstes jahr":
        start_milliseconds = (datetime.datetime(today.year + 1, 1, 1) - datetime.datetime(1970, 1,
                                                                                          1)).total_seconds() * 1000
        end_milliseconds = (datetime.datetime(today.year + 1, 12, 31) - datetime.datetime(1970, 1,
                                                                                          1)).total_seconds() * 1000

    session.attributes['when_start'] = int(start_milliseconds)
    session.attributes['when_end'] = int(end_milliseconds)

    pprint.pprint(str(when))

    return message_when_intent()
</code></pre>
  </div>
</div>

  </div>
  


  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
