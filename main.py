import loggingimport api_testimport datetimefrom flask import Flaskfrom flask_ask import Ask, session, question, statement, request#checkapp = Flask(__name__)ask = Ask(app, "/")logger = logging.getLogger()def build_speechlet_response(title, output, content, reprompt_text, should_end_session):    return {        'outputSpeech': {            'type': 'SSML',            'ssml': output        },        'card': {            'type': 'Simple',            'title': "My Best Friend - " + title,            'content': content        },        'reprompt': {            'outputSpeech': {                'type': 'PlainText',                'text': reprompt_text            }        },        'shouldEndSession': should_end_session    }def build_response(session_attributes, speechlet_response):    return {        'version': '1.0',        'sessionAttributes': session_attributes,        'response': speechlet_response    }@ask.launchdef launch():    if account_is_linked():        return question("Hey, what can I do for you?").reprompt("You could for example say: 'I want to study'.")    else:        return statement("There was a problem regarding your linked profile.")@ask.intent('HobbyIntent', mapping={'hobby': 'Hobby'})def hobby_intent(hobby):    session.attributes['hobby'] = hobby    if account_is_linked():        #token = getattr(session.user, 'accessToken')        #logger.debug(str(token))        return question("OK! When do you want to {}?".format(hobby)).reprompt("You could choose for example: 'this week' or 'next month")    else:        return statement("There was a problem regarding your linked calendar settings to your myalfred skill. Please have a look into your companion app to check the status.")@ask.intent('WhenIntent', mapping={'when': 'When'})def when_intent(when):    today = datetime.datetime.now()    if (when == "this week"):        start_milliseconds = (today - datetime.datetime(1970,1,1)).total_seconds()  * 1000        this_sunday = next_weekday(today, 0)        #duration = this_sunday #- today        #end_milliseconds = duration.total_seconds() * 1000        end_milliseconds = (this_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    elif (when == "next week"):        next_monday = next_weekday(today, 0)        next_sunday = next_weekday(next_monday, 0)        #duration = next_monday - today        #start_milliseconds = duration.total_seconds() * 1000        start_milliseconds = (next_monday - datetime.datetime(1970,1,1)).total_seconds()  * 1000        #duration = next_sunday - next_monday + today        #end_milliseconds = duration.total_seconds() * 1000        end_milliseconds = (next_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    elif (when == "this weekend"):        this_friday = next_weekday(today, 4)        this_sunday = next_weekday(this_friday, 0)        #duration = this_friday #- today        #start_milliseconds = duration.total_seconds() * 1000        start_milliseconds = (this_friday - datetime.datetime(1970,1,1)).total_seconds()  * 1000        #duration = this_sunday - this_friday + today        #end_milliseconds = duration.total_seconds() * 1000        end_milliseconds = (this_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    elif (when == "next weekend"):        this_sunday = next_weekday(today, 6)        next_friday = next_weekday(this_sunday, 4)        next_sunday = next_weekday(next_friday, 0)        #duration = next_friday #- today        #start_milliseconds = duration.total_seconds() * 1000        start_milliseconds = (next_friday - datetime.datetime(1970,1,1)).total_seconds()  * 1000        #duration = next_sunday - next_friday + today        #end_milliseconds = duration.total_seconds() * 1000        end_milliseconds = (next_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    #return int(start_milliseconds)    session.attributes['when_start'] = int(start_milliseconds)    session.attributes['when_end'] = int(end_milliseconds)    hobby = session.attributes.hobby    return question("How long will it take you?".format(start_milliseconds, end_milliseconds, hobby))@ask.intent('TimeDurationIntent', mapping={'timeduration': 'TimeDuration'})def convert_to_seconds_from(timeduration):    # PnYnMnWnDTnHnMnS    logger.debug(str(timeduration))    string = str(timeduration)    iso = string[1:]    length = len(iso)    hours = 0    logger.debug(str(iso))    if length == 0:        return statement("Something went wrong.")    if iso[0] is not 'T':        index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'Y':            years = iso[0:index]            days = int(years)*365            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'M':            months = iso[0:index]            days += int(months)*30            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'W':            weeks = iso[0:index]            days += int(weeks)*7            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'D':            days_str = iso[0:index]            days += int(days_str)            iso = iso[index + 1:]        seconds = days*24*3600    if iso[0] is 'T':        iso = iso[1:]        index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'H':            hours = iso[0:index]            seconds = (int(hours) * 3600)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'M':            minutes = iso[0:index]            seconds = (int(minutes) * 60)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'S':            seconds_str = iso[0:index]            seconds = (int(seconds_str))    milliseconds = seconds * 1000    session.attributes['duration'] = milliseconds    return question("OK. At what time of the day do you want to do it?".format(milliseconds))@ask.intent('TimeOfDayIntent', mapping={'time':'TimeOfDay'})def get_time_of_day(time):    if (time == "morning"):        starthours = 5;        endhours = 11;    elif (time == "midday"):        starthours = 10;        endhours = 14;    elif (time == "afternoon"):        starthours = 13;        endhours = 18;    elif (time == "evening"):        starthours = 17;        endhours = 22;    elif (time == "night"):        starthours = 21;        endhours = 5;    session.attributes['daytime_start'] = starthours    session.attributes['daytime_end'] = endhours    set_request()def set_request():    token = session.user.accessToken    hobby = session.attributes.hobby    when_start = session.attributes.when_start    when_end = session.attributes.when_end    duration = session.attributes.duration    daytime_start = session.attributes.daytime_start    daytime_end = session.attributes.daytime_end    test = {        # Get token from https://developers.google.com/oauthplayground/        "accessTokens": [ str(token) ],        "eventTitle": str(hobby),        "start": int(float(when_start)),        "end": int(float(when_end)),        "eventDuration": int(float(duration)),        "originatorId": "alexa-skill",        "startRanges": [            {                "startHours": int(float(daytime_start)),                "startMinutes": 0,                "endHours": int(float(daytime_end)),                "endMinutes": 0,                "timeZone": "Europe/Vienna"            }        ],        "location": {            "type": "Location",            "name": "Plus City Pasching",            "coordinates": {                "lat": 48.244179,                "lng": 14.23592            },            "address": None        },        "count": 1,        "isRepeating": False,        "repeatPeriod": 6,        "repeatInterval": 1    }    api_test.make_call_to_myalfred_api_2(test)    return statement("I have successfully found a suiting time and date. I have saved it into your calendar. Hope it's working out for you!")def next_weekday(day, weekday):    # weekday = 0 Monday, = 1 Tuesday,...    d = day.replace(hour=0, minute=0, second=0)    days_ahead = weekday - d.weekday()    if days_ahead <= 0: # Target day already happened this week        days_ahead += 7    return d + datetime.timedelta(days_ahead)def get_index_where_next_char_occurs(iso):    if iso is '':        return None    i = 0    numbers = '0123456789'    for char in iso:        if char not in numbers:            return i        i += 1    return Nonedef account_is_linked():    if hasattr(session, 'user') and hasattr(session.user, 'accessToken'):        return True    else:        return Falseif __name__ == "__main__":    app.run(debug=True)