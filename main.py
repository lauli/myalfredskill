# -*- coding: utf-8 -*-import loggingimport datetimeimport pprintimport jsonimport requestsfrom requests.auth import HTTPBasicAuthfrom flask import Flaskfrom flask_ask import Ask, session, question, statement, requestapp = Flask(__name__)ask = Ask(app, "/")logger = logging.getLogger()# ---------------------------------------------------------------------------------------------- INTENTS@ask.launchdef launch():    """    Launch event, which is called when user says 'start/open myalfred' Welcomes user, if account is linked. If     account is not linked, Alexa will say that there was an error and that the user should have a look into his     companion app to link skill (again). Furthermore, it will create a LinkedCard for the companion app so that user     has an easy way to link skill. :return: question, what user wants to do -> HobbyIntent. Or statement with linked     card when skill isn't linked.     """    if account_is_linked():        if str(request.locale) == "de-DE":            return question("Hallo, ich bin mei-Alfred. Was kann ich für dich tun?").reprompt(                "Du könntest zum Beispiel sagen 'Ich möchte lernen'.")        else:            return question("Hey, what can I do for you?").reprompt("You could for example say: 'I want to study'.")    else:        return message_account_linking()@ask.intent('HobbyIntent', mapping={'hobby': 'Hobby'})def hobby_intent(hobby):    """    This event is called whenever Alexa recognizes the 'HobbyIntent'. It checks token-availability too,     because sometimes user will skip the launch event. If account is not linked, Alexa will say that there was an     error and that the user should have a look into his companion app to link skill (again). Furthermore,     it will create a LinkedCard for the companion app so that user has an easy way to link skill. :param hobby:     mapped 'Hobby' slot value, f. e. "go running" :return: question when user wants to do his/her hobby ->     WhenIntent. Or statement with linked card when skill isn't linked.     """    session.attributes['hobby'] = hobby    return message_hobby_intent()@ask.intent('WhenIntent', mapping={'when': 'When'})def when_intent(when):    """    This event is called whenever Alexa recognizes the 'WhenIntent'.    Checks which slot value (i.e. "this week", "next month",...) was called     and calculates milliseconds for start and end date in json for myalfred-api-call.    :param when: mapped 'When' slot value, i.e. "this week"    :return: question, how long user think this event will be -> TimeDurationIntent    """    if session.attributes.hobby is not None:        return message_hobby_intent()    global start_milliseconds, end_milliseconds    today = datetime.datetime.now()    when = str(when).lower()    if when == "this week" or when == "diese woche":        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        this_sunday = next_weekday(today, 0)        end_milliseconds = (this_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif when == "next week" or when == "nächste woche":        next_monday = next_weekday(today, 0)        next_sunday = next_weekday(next_monday, 0)        start_milliseconds = (next_monday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (next_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif when == "this weekend" or when == "dieses wochenende":        this_friday = next_weekday(today, 4)        this_sunday = next_weekday(this_friday, 0)        start_milliseconds = (this_friday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (this_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif when == "next weekend" or when == "nächstes wochenende":        this_sunday = next_weekday(today, 6)        next_friday = next_weekday(this_sunday, 4)        next_sunday = next_weekday(next_friday, 0)        start_milliseconds = (next_friday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (next_sunday - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif when == "this month" or when == "dieses monat":        last_of_month = get_last_of_month(today)        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif when == "next month" or when == "nächstes monat":        first_of_month = datetime.datetime(today.year, (today.month + 1), 1)        last_of_month = get_last_of_month(first_of_month)        start_milliseconds = (first_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif when == "this year" or when == "dieses jahr":        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (                               datetime.datetime(today.year, 12, 31) - datetime.datetime(1970, 1,                                                                                         1)).total_seconds() * 1000    elif when == "next year" or when == "nächstes jahr":        start_milliseconds = (datetime.datetime(today.year + 1, 1, 1) - datetime.datetime(1970, 1,                                                                                          1)).total_seconds() * 1000        end_milliseconds = (datetime.datetime(today.year + 1, 12, 31) - datetime.datetime(1970, 1,                                                                                          1)).total_seconds() * 1000    session.attributes['when_start'] = int(start_milliseconds)    session.attributes['when_end'] = int(end_milliseconds)    pprint.pprint(str(when))    return message_when_intent()@ask.intent('TimeDurationIntent', mapping={'timeduration': 'TimeDuration'})def convert_to_seconds_from(timeduration):    """    This event is called whenever Alexa recognizes the 'TimeDurationIntent'.    Checks slot value, which must be a time reference in ISO-8601 duration format.    Calculates duartion in millicseconds for json for myalfred-api-call.    :param timeduration:  mapped 'TimeDuration' slot value, i.e. "PT1H" -> one hour    :return: question, at which time of the day the event should take place in -> TimeOfDayIntent    """    if session.attributes.hobby is not None:        return message_when_intent()    # PnYnMnWnDTnHnMnS    global days, seconds    string = str(timeduration)    iso = string[1:]    length = len(iso)    if length == 0:        if str(request.locale) == "de-DE":            return question("Leider hatte ich ein Problem die Zeitspanne zu berechnen. Wie lange wirst du brauchen?")        else:            return question(                "Something went wrong with calculating the time duration. Please try again. How long will it take you?")    if iso[0] is not 'T':        index = get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'Y':            years = iso[0:index]            days = int(years) * 365            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'M':            months = iso[0:index]            days += int(months) * 30            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'W':            weeks = iso[0:index]            days += int(weeks) * 7            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'D':            days_str = iso[0:index]            days += int(days_str)            iso = iso[index + 1:]        seconds = days * 24 * 3600    if iso[0] is 'T':        iso = iso[1:]        index = get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'H':            hours = iso[0:index]            seconds = (int(hours) * 3600)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'M':            minutes = iso[0:index]            seconds = (int(minutes) * 60)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'S':            seconds_str = iso[0:index]            seconds = (int(seconds_str))    milliseconds = seconds * 1000    session.attributes['duration'] = milliseconds    pprint.pprint(timeduration)    return message_duration_intent()@ask.intent('TimeOfDayIntent', mapping={'time': 'TimeOfDay'})def get_time_of_day(time):    """    This event is called whenever Alexa recognizes the 'TimeOfDayIntent'.    Checks slot value (i.e. "morning", "evening", ...) and calculates start and end hours for json for myalfred api call.    :param time: mapped 'TimeOfDay' slot value    :return: question, how often the event should be scheduled -> PeriodIntent    """    if session.attributes.hobby is not None:        return message_duration_intent()    global starthours, endhours    if time == "morning" or time == "morgen" or time == "vormittag":        starthours = 5        endhours = 11    elif time == "midday" or time == "mittag":        starthours = 10        endhours = 14    elif time == "afternoon" or time == "nachmittag":        starthours = 13        endhours = 18    elif time == "evening" or time == "abend":        starthours = 17        endhours = 22    elif time == "night" or time == "nacht":        starthours = 21        endhours = 5    session.attributes['daytime_start'] = starthours    session.attributes['daytime_end'] = endhours    pprint.pprint(time)    return message_time_of_day_intent()@ask.intent('PeriodIntent', mapping={'period': 'Period'})def get_time_of_day(period):    """       This event is called whenever Alexa recognizes the 'PeriodIntent'.       Checks slot value (i.e. "daily", "weekly", "not at all"...)        and calculates number for repeat period for json for myalfred api call.       Afterwards, calls set_request, which is calling the myalfred api with our input data.       If call was successfull, Alexa will reply that the event was created.        Otherwise, Alexa will tell the user that something went wrong.       :param period: mapped 'Period' slot value       :return: statement, which declares if the call was successfull or not    """    if session.attributes.hobby is not None:        return message_time_of_day_intent()    repeat = ""    if period is "daily" or period is "täglich":        repeat = 5    elif period is "weekly" or period is "wöchentlich":        repeat = 6    elif period is "yearly" or period is "jährlich":        repeat = 7    else:        set_request()    session.attributes['period'] = repeat    pprint.pprint(period)    return set_request()# ------------------------------------------------------------------------------------------- AMAZON.Intents@ask.intent('AMAZON.StopIntent')def stop():    """    This event is called whenever Alexa recognizes the 'AMAZON.StopIntent'.    Ends skill    :return: statement with send-off    """    if str(request.locale) is "de-DE":        return statement("OK. Noch einen schönen Tag!")    else:        return statement("OK. Have a nice day. Hope to see you soon!")# ---------------------------------------------------------------------------------------------- used FUNCTIONSdef next_weekday(day, weekday):    """    Calculates next upcoming day, that is described in param 'weekday' (weekday = 0 Monday, = 1 Tuesday,...)    :param day: daytime object, that describes current day    :param weekday: integer, that describes which upcoming day of the week should be searched for    :return: datetime object, that describes wanted upcoming day.    """    d = day.replace(hour=0, minute=0, second=0)    days_ahead = weekday - d.weekday()    if days_ahead <= 0:        days_ahead += 7    return d + datetime.timedelta(days_ahead)def get_index_where_next_char_occurs(iso):    """    Calculates next index where a character is situated.    i.e. 01234A -> index 5    :param iso: string    :return: index position    """    if iso is '':        return None    i = 0    numbers = '0123456789'    for char in iso:        if char not in numbers:            return i        i += 1    return Nonedef account_is_linked():    """    Checks if session includes an accesstoken or not    :return: True, if accesstoken exists. False if not    """    if session.user.accessToken is not None:        return True    else:        return Falsedef get_last_of_month(first_of_month):    """    Creates datetime object, which is the last day in 'first_of_month.month'    :param first_of_month: defines month in which the datetime object should be in    :return: datetime object    """    global last_of_month    if first_of_month.month in {1, 3, 5, 7, 8, 10, 12}:        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 31)    elif first_of_month in {4, 6, 9, 11}:        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 30)    elif first_of_month is 2:        if first_of_month.year % 4 is 0:            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 29)        else:            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 28)    return last_of_monthdef set_request():    """    Prepares JSON Object for our API call.    Retrieves all data, that was stored into our session, and saves it into a json object.    Afterwards, calls myalfred make_call_to_myalfred_api with mentioned json object.    :return:     """    token = session.user.accessToken    hobby = session.attributes.hobby    when_start = session.attributes.when_start    when_end = session.attributes.when_end    duration = session.attributes.duration    daytime_start = session.attributes.daytime_start    daytime_end = session.attributes.daytime_end    pprint.pprint(str(token) + "   hobby: " + str(hobby))    if session.attributes.period is not None and session.attributes.period is not "":        is_repeating = True        period = session.attributes.period    else:        is_repeating = False        period = 0    call = {        # Get token from https://developers.google.com/oauthplayground/        "accessTokens": [str(token)],        "eventTitle": str(hobby),        "start": int(float(when_start)),        "end": int(float(when_end)),        "eventDuration": int(float(duration)),        "originatorId": "alexa-skill",        "startRanges": [            {                "startHours": int(float(daytime_start)),                "startMinutes": 0,                "endHours": int(float(daytime_end)),                "endMinutes": 0,                "timeZone": "Europe/Vienna"            }        ],        "location": {            "type": "Location",            "name": "",            "coordinates": {                "lat": 48.244179,                "lng": 14.23592            },            "address": None        },        "count": 1,        "isRepeating": is_repeating,        "repeatPeriod": int(period),        "repeatInterval": 1    }    return make_call_to_myalfred_api(call)    # return state    #    #    #     return statement("I have successfully found a date for you. I have saved it into your calendar.")def make_call_to_myalfred_api(json_data):    """    Makes a POST-request to the myAlfred Scheduling API using a JSON object    containing Google Calendar token & desired scheduling setup and returns the response body.    :param json_data: the json request containing all relevant information about a desired event    :return: The response body of the scheduling api    """    url = 'https://staging.myalfred.io/api/schedule/google'    try:        r = requests.post(url, auth=HTTPBasicAuth('AmazonAlexaClient', '7m33P2K7tYhcgKNvNpd747pRFfo9H8'),                          json=json_data, timeout=None)        data = json.loads(r.text)        pprint.pprint(r.text)    except requests.exceptions.HTTPError as err:        print err        return statement("error")    except requests.exceptions.Timeout:        pprint.pprint("try again")        make_call_to_myalfred_api(json_data)    except requests.exceptions.TooManyRedirects:        pprint.pprint("bad url")        return statement("error")    except requests.exceptions.RequestException as e:        pprint.pprint("really bad error..")        print e        return statement("error")    except Exception:        pprint.pprint("exception all..")        return statement("error")    return message_success()    #start_date = convert_to_datetime_from_milliseconds(data['startDate'])    #pprint.pprint()    # if (str(request.locale) == "de-DE"):    #     return statement("Ich habe dir den Termin erfolgreich eingetragen. Er findet am {} um {} Uhr statt.".format(start_date.date, start_date.time))    # else:    #     return statement("Ich have successfully added the event to your calendar. The date is at {} at {}".format(start_date.date, start_date.time))def convert_to_datetime_from_milliseconds(milliseconds):    """    Converts milliseconds to datetime object    :param milliseconds: int    :return: datetime object    """    return datetime.datetime.fromtimestamp(milliseconds / 1000.0)# ------------------------------------------------------------------------------------------- Return Messagesdef message_account_linking():    """    Returns statement, that the account is not linked. Adds specific linking card.    :return: statement    """    if str(request.locale) == "de-DE":        return statement(            "Leider hatte ich ein Problem mich mit deinem Kalender zu verbinden. Bitte siehe in deinen"            "Einstellungen nach, ob du mich mit dem Kalender verknüpft hast.").link_account_card()    else:        return statement(            "There was a problem regarding your linked calendar settings to your myalfred skill. "            "Please have a look into your companion app to check the status.").link_account_card()def message_hobby_intent():    """    If account is linked, returns question, when the user wants to do this event    If not linked, returns 'message_account_linking'    :return: question or statement    """    if account_is_linked():        if str(request.locale) == "de-DE":            return question("OK! Wann möchtest du das machen?").reprompt(                "Du könntest zum Beispiel sagen 'nächste Woche'.")        else:            return question("OK! When do you want to do it?").reprompt(                "You could choose for example: 'this week' or 'next month")    else:        return message_account_linking()def message_when_intent():    """    Returns question, how long user will need to finish event.    :return: question    """    if str(request.locale) == "de-DE":        return question("Wie lange wirst du dafür brauchen?").reprompt(            "Du könntest zum Beispiel sagen 'Zwei Stunden wird es dauern'.")    else:        return question("How long will it take you?").reprompt("You could for example say 'it will take 2 hours'.")def message_duration_intent():    """    Returns question, at what time of the day the user wants to do the event    :return: question    """    if str(request.locale) == "de-DE":        return question("OK. Zu welcher ungefähren Tageszeit möchtest du es machen?").reprompt(            "Du könntest zum Beispiel sagen 'am Nachmittag'.")    else:        return question("OK. At what time of the day do you want to do it?").reprompt(            "You could for example say 'in the afternoon'.")def message_time_of_day_intent():    """    Returns question, if event should repeat itself    :return: question    """    if str(request.locale) == "de-DE":        return question("Soll sich der Termin täglich, wöchentlich, jährlich oder gar nicht wiederholen?").reprompt(            "Du könntest zum Beispiel sagen 'es soll sich gar nicht wiederholen'.")    else:        return question("Should the event repeat itself daily, weekly, yearly or not at all?").reprompt(            "You could for example say 'it should repeat not at all'.")def message_success():    """    Returns statement, that the creating was a success    :return: statement    """    if (str(request.locale) == "de-DE"):        return statement(            "Ich habe dir den Termin erfolgreich eingetragen")    else:        return statement(            "Ich have successfully added the event to your calendar")if __name__ == "__main__":    app.run(debug=True)