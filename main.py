import loggingimport datetimefrom flask import Flaskfrom flask_ask import Ask, session, question, statement, request#checkapp = Flask(__name__)ask = Ask(app, "/")logger = logging.getLogger()def build_speechlet_response(title, output, content, reprompt_text, should_end_session):    return {        'outputSpeech': {            'type': 'SSML',            'ssml': output        },        'card': {            'type': 'Simple',            'title': "My Best Friend - " + title,            'content': content        },        'reprompt': {            'outputSpeech': {                'type': 'PlainText',                'text': reprompt_text            }        },        'shouldEndSession': should_end_session    }def build_response(session_attributes, speechlet_response):    return {        'version': '1.0',        'sessionAttributes': session_attributes,        'response': speechlet_response    }@ask.launchdef launch():    if account_is_linked():        return question("Hey, what can I do for you?").reprompt("You could for example say: 'I want to study'.")    else:        return statement("There was a problem regarding your linked profile.")@ask.intent('HobbyIntent', mapping={'hobby': 'Hobby'})def hobby_intent(hobby):    session.attributes['hobby'] = hobby    if account_is_linked():        #token = getattr(session.user, 'accessToken')        #logger.debug(str(token))        return question("OK! When do you want to {}?".format(hobby)).reprompt("You could choose for example: 'this week' or 'next month")    else:        return statement("There was a problem regarding your linked calendar settings to your myalfred skill. Please have a look into your companion app to check the status.")@ask.intent('WhenIntent', mapping={'when': 'When'})def when_intent(when):    #session.attributes['when'] = when    #hobby = session.attributes.hobby    today = datetime.datetime.now()    if (when == "this week"):        start_milliseconds = 0        this_sunday = next_weekday(today, 6)        duration = this_sunday - today        end_milliseconds = duration.total_seconds() * 1000    elif (when == "next week"):        next_monday = next_weekday(today, 0)        next_sunday = next_weekday(next_monday, 6)        duration = next_monday - today        start_milliseconds = duration.total_seconds() * 1000        duration = next_sunday - next_monday        end_milliseconds = duration.total_seconds() * 1000    elif (when == "this weekend"):        this_friday = next_weekday(today, 4)        this_sunday = next_weekday(this_friday, 6)        duration = this_friday - today        start_milliseconds = duration.total_seconds() * 1000        duration = this_sunday - this_friday        end_milliseconds = duration.total_seconds() * 1000    elif (when == "next weekend"):        this_sunday = next_weekday(today, 6)        next_friday = next_weekday(this_sunday, 4)        next_sunday = next_weekday(next_friday, 6)        duration = next_friday - today        start_milliseconds = duration.total_seconds() * 1000        duration = next_sunday - next_friday        end_milliseconds = duration.total_seconds() * 1000    return question("You want me to find a date from {} milliseconds to {} milliseconds. Let's do that! How long will {}ing take you?".format(start_milliseconds, end_milliseconds, hobby))@ask.intent('TimeDurationIntent', mapping={'timeduration': 'TimeDuration'})def convert_to_seconds_from(timeduration):    # PnYnMnWnDTnHnMnS    logger.debug(str(timeduration))    string = str(timeduration)    iso = string[1:]    length = len(iso)    hours = 0    logger.debug(str(iso))    if length == 0:        return statement("Something went wrong.")    if iso[0] is not 'T':        index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'Y':            years = iso[0:index]            days = int(years)*365            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'M':            months = iso[0:index]            days += int(months)*30            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'W':            weeks = iso[0:index]            days += int(weeks)*7            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'D':            days_str = iso[0:index]            days += int(days_str)            iso = iso[index + 1:]        seconds = days*24*3600    if iso[0] is 'T':        iso = iso[1:]        index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'H':            hours = iso[0:index]            seconds = (int(hours) * 3600)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'M':            minutes = iso[0:index]            seconds = (int(minutes) * 60)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'S':            seconds_str = iso[0:index]            seconds = (int(seconds_str))    milliseconds = seconds * 1000    #return milliseconds    return question("These are {} milliseconds. At what time of the day do you want to do it?".format(milliseconds))@ask.intent('TimeOfDayIntent', mapping={'time':'TimeOfDay'})def get_time_of_day(time):    if (time == "morning"):        starthours = 5;        endhours = 11;    elif (time == "midday"):        starthours = 10;        endhours = 14;    elif (time == "afternoon"):        starthours = 13;        endhours = 18;    elif (time == "evening"):        starthours = 17;        endhours = 22;    elif (time == "night"):        starthours = 21;        endhours = 5;    return statement("")def next_weekday(day, weekday):    # weekday = 0 Monday, = 1 Tuesday,...    d = day.replace(hour=0, minute=0, second=0)    days_ahead = weekday - d.weekday()    if days_ahead <= 0: # Target day already happened this week        days_ahead += 7    return d + datetime.timedelta(days_ahead)def get_index_where_next_char_occurs(iso):    if iso is '':        return None    i = 0    numbers = '0123456789'    for char in iso:        if char not in numbers:            return i        i += 1    return Nonedef account_is_linked():    if hasattr(session, 'user') and hasattr(session.user, 'accessToken'):        return True    else:        return Falseif __name__ == "__main__":    app.run(debug=True)