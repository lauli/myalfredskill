# -*- coding: utf-8 -*-import loggingimport datetimeimport pprintimport callimport messagesimport methodsfrom flask import Flaskfrom flask_ask import Ask, sessionapp = Flask(__name__)ask = Ask(app, "/")logger = logging.getLogger()# ---------------------------------------------------------------------------------------------- INTENTS@ask.launchdef launch():    """    Launch event, which is called when user says 'start/open myalfred' Welcomes user, if account is linked. If     account is not linked, Alexa will say that there was an error and that the user should have a look into his     companion app to link skill (again). Furthermore, it will create a LinkedCard for the companion app so that user     has an easy way to link skill. :return: question, what user wants to do -> HobbyIntent. Or statement with linked     card when skill isn't linked.     """    return messages.message_welcome()@ask.intent('HobbyIntent', mapping={'hobby': 'Hobby'})def hobby_intent(hobby):    """    This event is called whenever Alexa recognizes the 'HobbyIntent'. It checks token-availability too,     because sometimes user will skip the launch event. If account is not linked, Alexa will say that there was an     error and that the user should have a look into his companion app to link skill (again). Furthermore,     it will create a LinkedCard for the companion app so that user has an easy way to link skill. :param hobby:     mapped 'Hobby' slot value, f. e. "go running" :return: question when user wants to do his/her hobby ->     WhenIntent. Or statement with linked card when skill isn't linked.     """    session.attributes['hobby'] = hobby    return messages.message_when()@ask.intent('WhenIntent', mapping={'when': 'When'})def when_intent(when):    """    This event is called whenever Alexa recognizes the 'WhenIntent'.    Checks which slot value (i.e. "this week", "next month",...) was called     and calculates milliseconds for start and end date in json for myalfred-api-call.    :param when: mapped 'When' slot value, i.e. "this week"    :return: question, how long user think this event will be -> TimeDurationIntent    """    if session.attributes.hobby is None:        return methods.check_session_attributes()    global start_milliseconds, end_milliseconds    today = datetime.datetime.now()    when = str(when).lower()    if when == "this week" or when == "diese woche":        start_milliseconds = methods.get_milliseconds_from_1970_until(today)        this_sunday = methods.next_weekday(today, 0)        end_milliseconds = methods.get_milliseconds_from_1970_until(this_sunday)    elif when == "next week" or when == "nächste woche":        next_monday = methods.next_weekday(today, 0)        next_sunday = methods.next_weekday(next_monday, 0)        start_milliseconds = methods.get_milliseconds_from_1970_until(next_monday)        end_milliseconds = methods.get_milliseconds_from_1970_until(next_sunday)    elif when == "this weekend" or when == "dieses wochenende":        this_friday = methods.next_weekday(today, 4)        this_sunday = methods.next_weekday(this_friday, 0)        start_milliseconds = methods.get_milliseconds_from_1970_until(this_friday)        end_milliseconds = methods.get_milliseconds_from_1970_until(this_sunday)    elif when == "next weekend" or when == "nächstes wochenende":        this_sunday = methods.next_weekday(today, 6)        next_friday = methods.next_weekday(this_sunday, 4)        next_sunday = methods.next_weekday(next_friday, 0)        start_milliseconds = methods.get_milliseconds_from_1970_until(next_friday)        end_milliseconds = methods.get_milliseconds_from_1970_until(next_sunday)    elif when == "this month" or when == "dieses monat":        start_milliseconds = methods.get_milliseconds_from_1970_until(today)        end_milliseconds = methods.get_milliseconds_from_1970_until(methods.get_last_of_month(today))    elif when == "next month" or when == "nächstes monat":        first_of_month = datetime.datetime(today.year, (today.month + 1), 1)        last_of_month = methods.get_last_of_month(first_of_month)        start_milliseconds = methods.get_milliseconds_from_1970_until(first_of_month)        end_milliseconds = methods.get_milliseconds_from_1970_until(last_of_month)    elif when == "this year" or when == "dieses jahr":        start_milliseconds = methods.get_milliseconds_from_1970_until(today)        end_milliseconds = methods.get_milliseconds_from_1970_until(datetime.datetime(today.year, 12, 31))    elif when == "next year" or when == "nächstes jahr":        start_milliseconds = methods.get_milliseconds_from_1970_until(datetime.datetime(today.year + 1, 1, 1))        end_milliseconds = methods.get_milliseconds_from_1970_until(datetime.datetime(today.year + 1, 12, 31))    session.attributes['when_start'] = int(start_milliseconds)    session.attributes['when_end'] = int(end_milliseconds)    pprint.pprint(str(when))    return messages.message_duration()@ask.intent('TimeDurationIntent', mapping={'timeduration': 'TimeDuration'})def convert_to_seconds_from(timeduration):    """    This event is called whenever Alexa recognizes the 'TimeDurationIntent'.    Checks slot value, which must be a time reference in ISO-8601 duration format.    Calculates duartion in millicseconds for json for myalfred-api-call.    :param timeduration:  mapped 'TimeDuration' slot value, i.e. "PT1H" -> one hour    :return: question, at which time of the day the event should take place in -> TimeOfDayIntent    """    if session.attributes.when_start is None:        return methods.check_session_attributes()    # PnYnMnWnDTnHnMnS    global days, seconds    string = str(timeduration)    iso = string[1:]    length = len(iso)    if length == 0:        return messages.message_failure()    if iso[0] is not 'T':        index = methods.get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'Y':            years = iso[0:index]            days = int(years) * 365            iso = iso[index + 1:]            index = methods.get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'M':            months = iso[0:index]            days += int(months) * 30            iso = iso[index + 1:]            index = methods.get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'W':            weeks = iso[0:index]            days += int(weeks) * 7            iso = iso[index + 1:]            index = methods.get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'D':            days_str = iso[0:index]            days += int(days_str)            iso = iso[index + 1:]        seconds = days * 24 * 3600    if iso[0] is 'T':        iso = iso[1:]        index = methods.get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'H':            hours = iso[0:index]            seconds = (int(hours) * 3600)            iso = iso[index + 1:]            index = methods.get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'M':            minutes = iso[0:index]            seconds = (int(minutes) * 60)            iso = iso[index + 1:]            index = methods.get_index_where_next_char_occurs(iso)        if index is not None and iso[index] is 'S':            seconds_str = iso[0:index]            seconds = (int(seconds_str))    milliseconds = seconds * 1000    session.attributes['duration'] = milliseconds    pprint.pprint(timeduration)    return messages.message_time_of_the_day()@ask.intent('TimeOfDayIntent', mapping={'time': 'TimeOfDay'})def get_time_of_day(time):    """    This event is called whenever Alexa recognizes the 'TimeOfDayIntent'.    Checks slot value (i.e. "morning", "evening", ...) and calculates start and end hours for json for myalfred api call.    :param time: mapped 'TimeOfDay' slot value    :return: question, how often the event should be scheduled -> PeriodIntent    """    if session.attributes.duration is None:        return methods.check_session_attributes()    global starthours, endhours    if time == "morning" or time == "morgen" or time == "vormittag":        starthours = 5        endhours = 11    elif time == "midday" or time == "mittag":        starthours = 10        endhours = 14    elif time == "afternoon" or time == "nachmittag":        starthours = 13        endhours = 18    elif time == "evening" or time == "abend":        starthours = 17        endhours = 22    elif time == "night" or time == "nacht":        starthours = 21        endhours = 5    session.attributes['daytime_start'] = starthours    session.attributes['daytime_end'] = endhours    pprint.pprint(time)    return messages.message_period()@ask.intent('PeriodIntent', mapping={'period': 'Period'})def get_time_of_day(period):    """       This event is called whenever Alexa recognizes the 'PeriodIntent'.       Checks slot value (i.e. "daily", "weekly", "not at all"...)        and calculates number for repeat period for json for myalfred api call.       Afterwards, calls set_request, which is calling the myalfred api with our input data.       If call was successfull, Alexa will reply that the event was created.        Otherwise, Alexa will tell the user that something went wrong.       :param period: mapped 'Period' slot value       :return: statement, which declares if the call was successfull or not    """    if session.attributes.daytime_start is None:        return methods.check_session_attributes()    repeat = ""    if period is "daily" or period is "täglich":        repeat = 5    elif period is "weekly" or period is "wöchentlich":        repeat = 6    elif period is "yearly" or period is "jährlich":        repeat = 7    else:        call.set_request()    session.attributes['period'] = repeat    pprint.pprint(period)    return call.set_request()# -------------------------------------------------------------------------------------------# -------------------------------------------------------------------------------------------# -------------------------------------------------------------------------------------------# ------------------------------------------------------------------------------------------- AMAZON.Intents# -------------------------------------------------------------------------------------------# -------------------------------------------------------------------------------------------# -------------------------------------------------------------------------------------------@ask.intent('AMAZON.StopIntent')def stop():    """    This event is called whenever Alexa recognizes the 'AMAZON.StopIntent'.    Ends skill    :return: statement with send-off    """    return messages.message_stop()@ask.intent('AMAZON.HelpIntent')def stop():    """    This event is called whenever Alexa recognizes the 'AMAZON.HelpIntent'.    Checks session attributes and gives user an idea of what he/she could say    Uses methods.check_session_attributes_for_help()    :return: question    """    return methods.check_session_attributes_for_help()if __name__ == "__main__":    app.run(debug=True)