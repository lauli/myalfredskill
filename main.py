# -*- coding: utf-8 -*-import loggingimport datetimeimport pprintimport requestsfrom requests.auth import HTTPBasicAuthfrom enum import Enumfrom flask import Flaskfrom flask_ask import Ask, session, question, statement, request#checkapp = Flask(__name__)ask = Ask(app, "/")logger = logging.getLogger()class RepeatPeriod(Enum):    DAILY = 5    WEEKLY = 6    YEARLY = 7# ---------------------------------------------------------------------------------------------- INTENTS@ask.launchdef launch():    if account_is_linked():        if (str(request.locale) == "de-DE"):            return question("Hallo, ich bin mei-Alfred. Was kann ich für dich tun?").reprompt("Du könntest zum Beispiel sagen 'Ich möchte lernen'.")        else:            return question("Hey, what can I do for you?").reprompt("You could for example say: 'I want to study'.")    else:        if (str(request.locale) == "de-DE"):            return statement("Leider hatte ich ein Problem mich mit deinem Kalender zu verknüpfen. Bitte siehe in deinen Einstellungen nach, ob du ich mit dem Kalender verknöpft bin.").link_account_card()        else:            return statement("There was a problem regarding your linked calendar settings to your myalfred skill. Please have a look into your companion app to check the status.").link_account_card()@ask.intent('HobbyIntent', mapping={'hobby': 'Hobby'})def hobby_intent(hobby):    session.attributes['hobby'] = hobby    if account_is_linked():        if (str(request.locale) == "de-DE"):            return question("OK! Wann möchtest du das machen?").reprompt("Du könntest zum Beispiel sagen 'nächste Woche'.")        else:            return question("OK! When do you want to {}?".format(hobby)).reprompt("You could choose for example: 'this week' or 'next month")    else:        if (str(request.locale) == "de-DE"):            return question("Leider hatte ich ein Problem mich mit deinem Kalender zu verbinden. Bitte siehe in deinen Einstellungen nach, ob du ich mit dem Kalender verknöpft bin.")        else:            return statement("There was a problem regarding your linked calendar settings to your myalfred skill. Please have a look into your companion app to check the status.")@ask.intent('WhenIntent', mapping={'when': 'When'})def when_intent(when):    today = datetime.datetime.now()    when = str(when).lower()    if (when == "this week" or when == "diese woche"):        start_milliseconds = (today - datetime.datetime(1970,1,1)).total_seconds()  * 1000        this_sunday = next_weekday(today, 0)        end_milliseconds = (this_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    elif (when == "next week" or when == "nächste woche"):        next_monday = next_weekday(today, 0)        next_sunday = next_weekday(next_monday, 0)        start_milliseconds = (next_monday - datetime.datetime(1970,1,1)).total_seconds()  * 1000        end_milliseconds = (next_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    elif (when == "this weekend" or when == "dieses wochenende"):        this_friday = next_weekday(today, 4)        this_sunday = next_weekday(this_friday, 0)        start_milliseconds = (this_friday - datetime.datetime(1970,1,1)).total_seconds()  * 1000        end_milliseconds = (this_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    elif (when == "next weekend" or when == "nächstes wochenende"):        this_sunday = next_weekday(today, 6)        next_friday = next_weekday(this_sunday, 4)        next_sunday = next_weekday(next_friday, 0)        start_milliseconds = (next_friday - datetime.datetime(1970,1,1)).total_seconds()  * 1000        end_milliseconds = (next_sunday - datetime.datetime(1970,1,1)).total_seconds()  * 1000    elif (when == "this month" or when == "dieses monat"):        last_of_month = get_last_of_month(today)        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif (when == "next month" or when == "nächstes monat"):        first_of_month = datetime.datetime(today.year, (today.month +1), 1)        last_of_month = get_last_of_month(first_of_month)        start_milliseconds = (first_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (last_of_month - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif (when == "this year" or when == "dieses jahr"):        start_milliseconds = (today - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (datetime.datetime(today.year, 12, 31) - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    elif (when == "next year" or when == "nächstes jahr"):        start_milliseconds = (datetime.datetime(today.year+1, 1, 1) - datetime.datetime(1970, 1, 1)).total_seconds() * 1000        end_milliseconds = (datetime.datetime(today.year+1, 12, 31) - datetime.datetime(1970, 1, 1)).total_seconds() * 1000    session.attributes['when_start'] = int(start_milliseconds)    session.attributes['when_end'] = int(end_milliseconds)    pprint.pprint(str(when))    if (str(request.locale) == "de-DE"):        return question("Wie lange wirst du dafür brauchen?").reprompt("Du könntest zum Beispiel sagen 'Zwei Stunden wird es dauern'.")    else:        return question("How long will it take you?").reprompt("You could for example say 'it will take 2 hours'.")@ask.intent('TimeDurationIntent', mapping={'timeduration': 'TimeDuration'})def convert_to_seconds_from(timeduration):    # PnYnMnWnDTnHnMnS    logger.debug(str(timeduration))    string = str(timeduration)    iso = string[1:]    length = len(iso)    hours = 0    logger.debug(str(iso))    if length == 0:        if (str(request.locale) == "de-DE"):            return question("Leider ging etwas schief. Tut mir leid.")        else:            return statement("Something went wrong.")    if iso[0] is not 'T':        index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'Y':            years = iso[0:index]            days = int(years)*365            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'M':            months = iso[0:index]            days += int(months)*30            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'W':            weeks = iso[0:index]            days += int(weeks)*7            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'D':            days_str = iso[0:index]            days += int(days_str)            iso = iso[index + 1:]        seconds = days*24*3600    if iso[0] is 'T':        iso = iso[1:]        index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'H':            hours = iso[0:index]            seconds = (int(hours) * 3600)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'M':            minutes = iso[0:index]            seconds = (int(minutes) * 60)            iso = iso[index + 1:]            index = get_index_where_next_char_occurs(iso)        if index != None and iso[index] is 'S':            seconds_str = iso[0:index]            seconds = (int(seconds_str))    milliseconds = seconds * 1000    session.attributes['duration'] = milliseconds    if (str(request.locale) == "de-DE"):        return question("OK. Zu welcher ungefähren Tageszeit möchtest du es machen?".format(milliseconds)).reprompt("Du könntest zum Beispiel sagen 'am Nachmittag'.")    else:        return question("OK. At what time of the day do you want to do it?".format(milliseconds)).reprompt("You could for example say 'in the afternoon'.")@ask.intent('TimeOfDayIntent', mapping={'time':'TimeOfDay'})def get_time_of_day(time):    #return statement("accessToken: {}".format(str(session.user.accessToken)))    if (time == "morning" or time == "morgen" or time == "vormittag"):        starthours = 5;        endhours = 11;    elif (time == "midday" or time == "mittag"):        starthours = 10;        endhours = 14;    elif (time == "afternoon" or time == "nachmittag"):        starthours = 13;        endhours = 18;    elif (time == "evening" or time == "abend"):        starthours = 17;        endhours = 22;    elif (time == "night" or time == "nacht"):        starthours = 21;        endhours = 5;    session.attributes['daytime_start'] = starthours    session.attributes['daytime_end'] = endhours    if (str(request.locale) == "de-DE"):        return question("Soll sich der Termin täglich, wöchentlich, jährlich oder gar nicht wiederholen?").reprompt("Du könntest zum Beispiel sagen 'es soll sich gar nicht wiederholen'.")    else:        return question("Should the event repeat itself daily, weekly, yearly or not at all?").reprompt("You could for example say 'it should repeat not at all'.")@ask.intent('PeriodIntent', mapping={'period':'Period'})def get_time_of_day(period):    repeat = ""    if (period == "daily" or period == "täglich"):        repeat = 5    elif (period == "weekly" or period == "wöchentlich"):        repeat = 6    elif (period == "yearly" or period == "jährlich"):        repeat = 7    else:        set_request()    session.attributes['period'] = repeat    set_request()# ---------------------------------------------------------------------------------------------- used FUNCTIONSdef build_speechlet_response(title, output, content, reprompt_text, should_end_session):    return {        'outputSpeech': {            'type': 'SSML',            'ssml': output        },        'card': {            'type': 'LinkAccount'#,            #'title': "My Best Friend - " + title,            #'content': content        },        'reprompt': {            'outputSpeech': {                'type': 'PlainText',                'text': reprompt_text            }        },        'shouldEndSession': should_end_session    }def build_response(session_attributes, speechlet_response):    return {        'version': '1.0',        'sessionAttributes': session_attributes,        'response': speechlet_response    }def set_request():    token = session.user.accessToken    hobby = session.attributes.hobby    when_start = session.attributes.when_start    when_end = session.attributes.when_end    duration = session.attributes.duration    daytime_start = session.attributes.daytime_start    daytime_end = session.attributes.daytime_end    pprint.pprint(str(token) + "   hobby: " + str(hobby))    if(session.attributes.period != None and session.attributes.period != ""):        isRepeating = True        period = session.attributes.period    else:        isRepeating = False        period = 0    call = {        # Get token from https://developers.google.com/oauthplayground/        "accessTokens": [ str(token) ],        "eventTitle": str(hobby),        "start": int(float(when_start)),        "end": int(float(when_end)),        "eventDuration": int(float(duration)),        "originatorId": "alexa-skill",        "startRanges": [            {                "startHours": int(float(daytime_start)),                "startMinutes": 0,                "endHours": int(float(daytime_end)),                "endMinutes": 0,                "timeZone": "Europe/Vienna"            }        ],        "location": {            "type": "Location",            "name": "",            "coordinates": {                "lat": 48.244179,                "lng": 14.23592            },            "address": None        },        "count": 1,        "isRepeating": isRepeating,        "repeatPeriod": int(period),        "repeatInterval": 1    }    state = statement("Alles klar, ich hab dir deinen Termin erfolgreich eingetragen!")    return make_call_to_myalfred_api_2(call)    return state    if (str(request.locale) == "de-DE"):        return state    else:        return statement("I have successfully found a date for you. I have saved it into your calendar.")def next_weekday(day, weekday):    # weekday = 0 Monday, = 1 Tuesday,...    d = day.replace(hour=0, minute=0, second=0)    days_ahead = weekday - d.weekday()    if days_ahead <= 0: # Target day already happened this week        days_ahead += 7    return d + datetime.timedelta(days_ahead)def get_index_where_next_char_occurs(iso):    if iso is '':        return None    i = 0    numbers = '0123456789'    for char in iso:        if char not in numbers:            return i        i += 1    return Nonedef account_is_linked():    if (session.user.accessToken != None):        return True    else:        return Falsedef get_last_of_month(first_of_month):    if (first_of_month.month == 1, 3, 5, 7, 8, 10, 12):        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 31)    elif (first_of_month == 4, 6, 9, 11):        last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 30)    elif (first_of_month == 2):        if (first_of_month.year % 4 == 0):            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 29)        else:            last_of_month = datetime.datetime(first_of_month.year, first_of_month.month, 28)    return last_of_monthdef make_call_to_myalfred_api_2(json_data):    """    Makes a POST-request to the myAlfred Scheduling API using a JSON object    containing Google Calendar token & desired scheduling setup and returns the response body.    :param json_data: the json request containing all relevant information about a desired event    :return: The response body of the scheduling api    """    url = 'https://staging.myalfred.io/api/schedule/google'    try:        r = requests.post(url, auth=HTTPBasicAuth('AmazonAlexaClient', '7m33P2K7tYhcgKNvNpd747pRFfo9H8'), json=json_data)        #data = json.loads(r.text)        pprint.pprint(r.text)        r.raise_for_status()    except requests.exceptions.HTTPError as err:        print err        return "shit"    # except requests.exceptions.Timeout:    #     pprint.pprint("try again")    #     make_call_to_myalfred_api_2(json_data)    # except requests.exceptions.TooManyRedirects:    #     pprint.pprint("bad url")    #     return "sdfa"    # except requests.exceptions.RequestException as e:    #     pprint.pprint("really bad error..")    #     print e    #     return "dfa"    pprint.pprint("geklappt..")    return statement("geklappt")# ------------------------------------------------------------------------------------------- AMAZON.Intents@ask.intent('AMAZON.StopIntent')def get_time_of_day(period):    if (str(request.locale) == "de-DE"):        return statement("OK. Noch einen schönen Tag!")    else:        return statement("OK. Have a nice day. Hope to see you soon!")if __name__ == "__main__":    app.run(debug=True)